# LATENT MIXTURE INDIVIDUAL
# v2 execution error decision rule
model{
  z ~ dcat(rep(1, nModels))
  for (j in 1:nTrials){
    decision[j] ~ dbern(theta[j, z])  
  }
  # EXPONENTIAL
  epsilonEX ~ dunif(0, 0.5)
  kappaEX ~ dlnorm(0, precision)
  for (j in 1:nTrials){
    valueLLEX[j] =  rLL[j]*exp(-kappaEX*tLL[j])
    valueSSEX[j] =  rSS[j]*exp(-kappaEX*tSS[j])
    theta[j, 1] = ifelse(step(valueLLEX[j] - valueSSEX[j]), 1-epsilonEX, epsilonEX)
  }
  # HYPERBOLIC
  epsilonHC ~ dunif(0, 0.5)
  kappaHC ~ dlnorm(0, precision)
  for (j in 1:nTrials){
    valueLLHC[j] =  rLL[j]/(1 + kappaHC*tLL[j])
    valueSSHC[j] =  rSS[j]/(1 + kappaHC*tSS[j])
    theta[j, 2] = ifelse(step(valueLLHC[j] - valueSSHC[j]), 1-epsilonHC, epsilonHC)
  }
  # HYPERBOLOID
  epsilonHY ~ dunif(0, 0.5)
  kappaHY ~ dlnorm(0, precision)
  tauHY ~ dlnorm(0, precision)
  for (j in 1:nTrials){
    valueLLHY[j] =  rLL[j]/(1 + kappaHY*tLL[j])^tauHY
    valueSSHY[j] =  rSS[j]/(1 + kappaHY*tSS[j])^tauHY
    theta[j, 3] = ifelse(step(valueLLHY[j] - valueSSHY[j]), 1-epsilonHY, epsilonHY)
  }
  # PROPORTIONAL DIFFERENCES
  epsilonPD ~ dunif(0, 0.5)
  deltaPD ~ dnorm(0, precision)
  for (j in 1:nTrials){
    diffRewardRPD[j] = (rLL[j] - rSS[j])/rLL[j]
    diffTimeRPD[j] = (tLL[j] - tSS[j])/tLL[j]
    theta[j, 4] = ifelse(step(diffRewardRPD[j] - diffTimeRPD[j] - deltaPD), 1-epsilonPD, epsilonPD)
  }
  # DIRECT DIFFERENCES
  epsilonDD ~ dunif(0, 0.5)
  deltaDD ~ dnorm(0, precision)
  omegaDD ~ dunif(0, 1)
  for (j in 1:nTrials){
    diffRewardRDD[j] = omegaDD*(rLL[j] - rSS[j])
    diffTimeRDD[j] = (1 - omegaDD)*(tLL[j] - tSS[j])
    theta[j, 5] = ifelse(step(diffRewardRDD[j] - diffTimeRDD[j] - deltaDD), 1-epsilonDD, epsilonDD)
  }
  # TRADEOFF
  epsilonTR ~ dunif(0, 0.5)
  gammaTR ~ dlnorm(0, precision)
  tauTR ~ dlnorm(0, precision)
  kappaTR ~ dlnorm(0, precision)
  varthetaTR ~ dlnorm(0, precision)
  for (j in 1:nTrials){
    valueLLTR[j] = 1/gammaTR*log(1 + gammaTR*rLL[j])        
    valueSSTR[j] = 1/gammaTR*log(1 + gammaTR*rSS[j])
    weightLLTR[j] = 1/tauTR*log(1 + tauTR*tLL[j])
    weightSSTR[j] = 1/tauTR*log(1 + tauTR*tSS[j])
    qValueTR[j] = valueLLTR[j] - valueSSTR[j]
    qTimeTR[j] = kappaTR*log(1 + ((weightLLTR[j] - weightSSTR[j])/varthetaTR)^varthetaTR)
    theta[j, 6] = ifelse(step(qValueTR[j] - qTimeTR[j]), 1-epsilonTR, epsilonTR)
  }
  # ITCH
  epsilonIT ~ dunif(0, 0.5)
  beta0IT ~ dnorm(0, precision)
  betaRAIT ~ dnorm(0, precision)
  betaRRIT ~ dnorm(0, precision)
  betaTAIT ~ dnorm(0, precision)
  betaTRIT ~ dnorm(0, precision)
  for (j in 1:nTrials){
    diffRewardAIT[j] = betaRAIT*(rLL[j] - rSS[j])
    diffRewardRIT[j] = betaRRIT*((rLL[j] - rSS[j])/(0.5*(rLL[j] + rSS[j])))
    diffTimeAIT[j] = betaTAIT*(tLL[j] - tSS[j])
    diffTimeRIT[j] = betaTRIT*((tLL[j] - tSS[j])/(0.5*(tLL[j] + tSS[j])))
    theta[j, 7] = ifelse(step(beta0IT + diffRewardAIT[j] + diffRewardRIT[j] + diffTimeAIT[j] + diffTimeRIT[j]), 1-epsilonIT, epsilonIT)
  }
  # GUESS 
  for (j in 1:nTrials){
      theta[j, 8] = 0.5
  }
  # LL 
  alphaLL ~ dunif(0.9, 1)
  for (j in 1:nTrials){
    theta[j, 9] = alphaLL
  }
  # SS 
  alphaSS ~ dunif(0.9, 1)
  for (j in 1:nTrials){
    theta[j, 10] = 1-alphaSS
  }
}